# 數組

## 题目链接

https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/submissions/

力扣581. 最短无序连续子数组

這題無需特殊的技巧，但利用sort比對會出現問題(排序前後在同一個位置)   
巧妙的解法：找出破壞升續的

---------------------------------------

```cpp
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int Max = INT_MIN;
        int Min = INT_MAX;
        int l = 0; //l為破壞降序的最左
        int r = 0; //r為破壞升序的最右
        //從左往右找哪個元素破壞升序，用r存取哪個破壞升序
        for(int i = 0; i<nums.size(); i++){ 
            if(Max>nums[i]){
                r = i;
            }
            Max = max(Max, nums[i]);
        }
        //從右往左找哪個元素破壞降序，用l取哪個破壞降序
        for(int i = nums.size()-1; i>=0; i--){
            if(Min<nums[i]){
                l = i;
            }
            Min = min(nums[i],Min);
        }
        //若都無破壞說明數組已被排序，答案是0
        return r==l? 0:r-l+1;
    }
};
```
